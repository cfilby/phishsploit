'use strict';

/**
 * Module containing Exploit API calls.
 * @module phishsploit/models/exploit.js
 */

import Promise from 'bluebird';
import express from 'express';

import config from '../config/config';
import {
  Exploit
}
from '../models/index';

let router = express.Router();

/**
 * @api {get} /exploits Get Exploits
 * @apiName getExploits
 * @apiGroup Exploits
 *
 * @apiParam {number} [page] number of the page to fetch
 *
 * @apiDescription
 * Get exploits.
 *
 * @apiSuccess {object} Response object
 * @apiSuccessExample {json} Success-Response:
 * HTTP/1.1 200 OK
 * {
 *  "title": "Exploit List",
 *  "exploits": [
 *    {
 *      "exploitId": 1,
 *      "description": "Microsoft Windows WebDAV - (ntdll.dll) Remote Exploit",
 *      "date": "2003-03-23T06:00:00.000Z",
 *      "author": "kralor",
 *      "platform": "windows",
 *      "type": "remote",
 *      "port": 80
 *    }, ...
 *  ],
 *  "total": {
 *    "count": "33999"
 *  },
 *  "page": {
 *    "current": 1,
 *    "size": 25,
 *    "range": 7,
 *    "route": "/exploits"
 *  }
 * }
 */
router.get('/',
  /**
   * Get Exploit objects.
   * @param  {Express.Request} req Express Request
   * @param  {Express.Response} res Express Response
   * @param  {Function} next Express Next function
   * @return {Object} Formatted response
   * @function getExploits
   */
  function getExploits(req, res, next) {
    let page = req.query.page || 1;
    let limit = config.page.size;

    Promise.props({
      title: 'Exploit List',
      exploits: Exploit.getMany(limit, (page - 1) * limit),
      total: Exploit.getCount(),
      page: {
        current: parseInt(page),
        size: limit,
        range: config.page.paginationRange,
        route: '/exploits'
      }
    }).then(function(exploitsObj) {
      return res.format({
        text: function() {
          return res.send(JSON.stringify(exploitsObj));
        },

        html: function() {
          return res.render('pages/exploits', exploitsObj);
        },

        json: function() {
          return res.json(exploitsObj);
        }
      });
    }).catch(function(err) {
      if (typeof err !== Error) {
        err = new Error(err);
      }

      return next(err);
    });
  });

/**
 * @api {get} /exploits/:type Get Exploits By Type
 * @apiName getExploitsByType
 * @apiGroup Exploits
 *
 * @apiParam {string} type
 * @apiParam {number} [page]
 *
 * @apiDescription
 * Get Exploits by their ExploitDB type.
 *
 * @apiSuccess {object} Response object
 * @apiSuccessExample {json} Success-Response:
 * HTTP/1.1 200 OK
 * {
 *  "title": "Exploits List: webapps",
 *  "exploits": [
 *    {
 *      "exploitId": 37666,
 *      "description": "Joomla! Helpdesk Pro Plugin < 1.4.0 - Multiple Vulnerabilities",
 *      "date": "2015-07-21T05:00:00.000Z",
 *      "author": "Simon Rawet",
 *      "platform": "php",
 *      "type": "webapps",
 *      "port": 80
 *    }, ...
 *  ],
 *  "total": {
 *    "count": "19862"
 *  },
 *  "page": {
 *    "current": 1,
 *    "size": 25,
 *    "range": 7,
 *    "route": "/exploits/type/webapps"
 *  }
 * }
 */
router.get('/type/:type',
  /**
   * Get Exploit by category objects.
   * @param  {Express.Request} req Express Request
   * @param  {Express.Response} res Express Response
   * @param  {Function} next Express Next function
   * @return {Object} Formatted response
   * @function getExploitsByType
   */
  function getExploitsByType(req, res, next) {
    let page = req.query.page || 1;
    let limit = config.page.size;

    Promise.props({
      title: 'Exploits List: ' + req.params.type,
      exploits: Exploit.getManyByType(req.params.type, limit, (page - 1) * limit),
      total: Exploit.getTypeCount(req.params.type),
      page: {
        current: parseInt(page),
        size: limit,
        range: config.page.paginationRange,
        route: '/exploits/type/' + req.params.type
      }
    }).then(function(exploitsObj) {
      return res.format({
        text: function() {
          return res.send(JSON.stringify(exploitsObj));
        },

        html: function() {
          return res.render('pages/exploits', exploitsObj);
        },

        json: function() {
          return res.json(exploitsObj);
        }
      });
    }).catch(function(err) {
      if (typeof err !== Error) {
        err = new Error(err);
      }

      return next(err);
    });
  });

/**
 * @api {get} /exploits/phishsploits Get PhishSploits
 * @apiName GetPhishSploits
 * @apiGroup Exploits
 *
 * @apiParam {number} page
 *
 * @apiDescription
 * Get a list of exploits with associated phish.
 *
 * @apiSuccess {object} Response object*
 * @apiSuccessExample {json} Success-Response:
 * HTTP/1.1 200 Ok
 * {
 *  "title": "Linked Exploits",
 *  "exploits": [
 *    {
 *      "exploitId": 37604,
 *      "description": "SO Planning 1.32 - Multiple Vulnerabilities",
 *      "date": "2015-07-13T05:00:00.000Z",
 *      "author": "Huy-Ngoc DAU",
 *      "platform": "php",
 *      "type": "webapps",
 *      "port": 80
 *    }
 *  ],
 *  "total": {
 *    "count": "1"
 *  },
 *  "page": {
 *    "current": 1,
 *    "size": 25,
 *    "range": 7,
 *    "route": "/exploits/phishsploits"
 *  }
 * }
 */
router.get('/phishsploits',
  /**
   * Get Exploit objects.
   * @param  {Express.Request} req Express Request
   * @param  {Express.Response} res Express Response
   * @param  {Function} next Express Next function
   * @return {Object} Formatted response
   * @function getPhishSploits
   */
  function getPhishSploits(req, res, next) {
    let page = req.query.page || 1;
    let limit = config.page.size;

    Promise.props({
      title: 'Linked Exploits',
      exploits: Exploit.getInterestingExploits(limit, (page - 1) * limit),
      total: Exploit.getInterestingExploitsCount(),
      page: {
        current: parseInt(page),
        size: limit,
        range: config.page.paginationRange,
        route: '/exploits/phishsploits'
      }
    }).then(function(exploitsObj) {
      return res.format({
        text: function() {
          return res.send(JSON.stringify(exploitsObj));
        },

        html: function() {
          return res.render('pages/exploits', exploitsObj);
        },

        json: function() {
          return res.json(exploitsObj);
        }
      });
    }).catch(function(err) {
      if (typeof err !== Error) {
        err = new Error(err);
      }

      return next(err);
    });
  });

/**
 * @api {get} /exploits/specific/:exploitId Get Specific Exploit
 * @apiName GetSpecificExploit
 * @apiGroup Exploits
 *
 * @apiParam {number} exploitId id of the exploit to fetch
 *
 * @apiDescription
 * Get a specific exploit from the database.
 *
 * @apiSuccess {object} Response object*
 * @apiSuccessExample {json} Success-Response:
 * HTTP/1.1 200 Ok
 * {
 * 	"exploit": {
 *   "exploitId": 1,
 *   "description": "Microsoft Windows WebDAV - (ntdll.dll) Remote Exploit",
 *   "date": "2003-03-23T06:00:00.000Z",
 *   "author": "kralor",
 *   "platform": "windows",
 *   "type": "remote",
 *   "port": 80
 *  },
 *  "exploitFile": {
 *   "exploitId": 1,
 *   "fileName": "1.c",
 *   "content": {
 *     "type": "Buffer",
 *     "data": [...]
 *   }
 *  },
 * 	"exploitKeyPaths": [],
 * 	"phish": [],
 * }
 */
router.get('/specific/:exploitId',
  /**
   * Get specific exploit.
   * @param  {Express.Request} req Express Request
   * @param  {Express.Response} res Express Response
   * @param  {Function} next Express Next function
   * @return {Object} Formatted response
   * @function getSpecificExploit
   */
  function getSpecificExploit(req, res, next) {
    Promise.props({
      exploit: Exploit.getOne(req.params.exploitId),
      exploitFile: Exploit.getFile(req.params.exploitId),
      exploitKeyPaths: Exploit.getKeyPaths(req.params.exploitId),
      phish: Exploit.getPhish(req.params.exploitId)
    }).then(function(exploitObj) {
      return res.format({
        text: function() {
          return res.send(JSON.stringify(exploitObj));
        },

        html: function() {
          return res.render('pages/exploit', exploitObj);
        },

        json: function() {
          return res.json(exploitObj);
        }
      });
    }).catch(function(err) {
      if (typeof err !== Error) {
        err = new Error(err);
      }

      return next(err);
    });
  });

export default router;
