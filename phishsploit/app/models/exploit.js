'use strict';

/**
 * Module containing functions responsible for querying the database for
 * Exploit related data.
 * @module phishsploit/models/exploit
 */

import * as db from './db/util';
import * as schema from './db/schema';

let phish = schema.phish;
let exploit = schema.exploit;
let exploitFile = schema.exploitFile;
let exploitKeyPath = schema.exploitKeyPath;
let exploitPhish = schema.exploitPhish;
let exploitPhishFrequency = schema.exploitPhishFrequency;

/**
 * Get a speicfied exploit from the database.
 * @param  {number} exploitId id of the exploit to fetch
 * @param  {Function} [callback] optional err/result callback
 * @return {Promise} Promise with corresponding Phish
 */
export function getOne(exploitId, callback) {
  let getExploitQuery = exploit.select()
    .where(exploit.exploitId.equals(exploitId))
    .toQuery();

  return db.queryOne(getExploitQuery.text, getExploitQuery.values)
    .nodeify(callback);
}

/**
 * Get a number of Exploits from the database.
 * @param  {number} limit=50 maximum number of exploits to fetch
 * @param  {number} offset=0 offset for exploits to fetch
 * @param  {Function} [callback] optional err/result callback
 * @return {Promise} Promise with corresponding File
 */
export function getMany(limit = 50, offset = 0, callback) {
  let getExploitsQuery = exploit.select()
    .order(exploit.exploitId)
    .limit(limit)
    .offset(offset)
    .toQuery();

  return db.queryMany(getExploitsQuery.text, [])
    .nodeify(callback);
}

/**
 * Get the total number of Exploits from the database.
 * @param  {number} limit=50 maximum number of exploits to fetch
 * @param  {number} offset=0 offset for exploits to fetch
 * @param  {Function} [callback] optional err/result callback
 * @return {Promise} Promise with corresponding count
 */
export function getCount(limit = 50, offset = 0, callback) {
  let getExploitsQuery = exploit.select(exploit.exploitId.count().as('count'))
    .toQuery();

  return db.queryOne(getExploitsQuery.text, [])
    .nodeify(callback);
}

/**
 * Get a set number of Exploits from the database by type.
 * @param  {string} type type of exploit to fetch
 * @param  {number} limit=50 maximum number of exploits to fetch
 * @param  {number} offset=0 offset for exploits to fetch
 * @param  {Function} [callback] optional err/result callback
 * @return {Promise} Promise with corresponding exploits
 */
export function getManyByType(type, limit = 50, offset = 0, callback) {
  let getExploitsQuery = exploit.select()
    .where(exploit.type.equals(type))
    .order(exploit.exploitId.descending)
    .limit(limit)
    .offset(offset)
    .toQuery();

  return db.queryMany(getExploitsQuery.text, getExploitsQuery.values)
    .nodeify(callback);
}

/**
 * Get the number of Exploits from the database of a given type.
 * @param  {string} type type of exploit to fetch
 * @param  {Function} [callback] optional err/result callback
 * @return {Promise} Promise with the corresponding count
 */
export function getTypeCount(type, callback) {
  let getExploitCountQuery = exploit.select(exploit.exploitId.count().as('count'))
    .where(exploit.type.equals(type))
    .toQuery();

  return db.queryOne(getExploitCountQuery.text, getExploitCountQuery.values)
    .nodeify(callback);
}

/**
 * Get all related exploits by their file content.
 * @param  {[type]} term key term to find in an exploit file.
 * @param  {number} limit=50 maximum number of exploits to fetch
 * @param  {number} offset=0 offset for exploits to fetch
 * @param  {Function} [callback] optional err/result callback
 * @return {Promise} Promise with corresponding exploits
 */
export function getByContent(term, limit = 50, offset = 0, callback) {
  let getExploitsByContentQuery = exploit.select()
    .where(exploit.exploitId.in(
      exploitFile.subQuery().select(exploitFile.exploitId)
      .where(exploitFile.content.like('%' + term + '%'))
    ))
    .limit(limit)
    .offset(offset)
    .toQuery();

  return db.query(getExploitsByContentQuery.text, getExploitsByContentQuery.values)
    .nodeify(callback);
}

/**
 * Get the number of exploits containing the specified content.
 * @param  {[type]} term key term to find in an exploit file.
 * @param  {Function} [callback] optional err/result callback
 * @return {Promise} Promise with corresponding exploits
 */
export function getByContentCount(term, callback) {
  let getExploitsByContentQuery = exploitFile.select(exploitFile.exploitId.count().as('count'))
    .where(exploitFile.content.like('%' + term + '%'))
    .toQuery();

  return db.queryOne(getExploitsByContentQuery.text, getExploitsByContentQuery.values)
    .nodeify(callback);
}

/**
 * Get the exploit file associated with a given exploit.
 * @param  {number} exploitId id of the exploit to fetch the associated file for
 * @param  {Function} [callback] optional err/result callback
 * @return {Promise} Promise with corresponding File
 */
export function getFile(exploitId, callback) {
  let getExploitFileQuery = exploitFile.select()
    .where(exploitFile.exploitId.equals(exploitId))
    .toQuery();

  return db.queryOne(getExploitFileQuery.text, getExploitFileQuery.values)
    .nodeify(callback);
}

/**
 * Get key paths that potential identify Phish associated with this Exploit.
 * @param  {number} exploitId id of the exploit to fetch key paths for
 * @param  {Function} [callback] optional err/result callback
 * @return {Promise} Promise with corresponding KeyPaths
 */
export function getKeyPaths(exploitId, callback) {
  let getExploitKeyPathQuery = exploitKeyPath.select()
    .where(exploitKeyPath.exploitId.equals(exploitId))
    .toQuery();

  return db.query(getExploitKeyPathQuery.text,
      getExploitKeyPathQuery.values)
    .nodeify(callback);
}

/**
 * Given an exploitId, query for any corresponding Phish based on the
 * exploitKeyPath table.
 * @param  {number} exploitId id of the exploit to fetch corresponding Phish
 * @param  {number} limit=50 maximum number of exploits to fetch
 * @param  {number} offset=0 offset for exploits to fetch
 * @param  {Function} [callback] optional err/result callback
 * @return {Promise} Promise with corresponding Phishes
 */
export function getPhish(exploitId, limit = 50, offset = 0, callback) {
  let getExploitPhishQuery = phish.select()
    .where(phish.phishId.in(
      exploitPhish.subQuery().select(exploitPhish.phishId)
      .where(exploitPhish.exploitId.equals(exploitId))
      .limit(limit)
      .offset(0)
    )).toQuery();

  return db.query(getExploitPhishQuery.text, getExploitPhishQuery.values)
    .nodeify(callback);
}

/**
 * Get the total number of PhishSploits.
 * @param  {Function} [callback] optional err/result callback
 * @return {Promise} Promise with corresponding PhishSploit count
 */
export function getExploitPhishCount(callback) {
  let getExploitPhishCountQuery = exploitPhish.select(exploitPhish.exploitId.count().as('count'))
    .toQuery();

  return db.queryOne(getExploitPhishCountQuery.text, getExploitPhishCountQuery.values)
    .nodeify(callback);
}

/**
 * Get a set of exploits with reported phish associated with them.
 * @param {number} limit number of interesting exploits to fetch
 * @param  {Function} [callback] optional err/result callback
 * @return {Promise} Promise with corresponding PhishSploit count
 */
export function getInterestingExploits(limit = 5, callback) {
  let getInterestingExploitsQuery = exploit.select()
    .where(exploit.exploitId.in(
      exploitPhishFrequency.subQuery().select(exploitPhishFrequency.exploitId)
      .order(exploitPhishFrequency.frequency.descending)
      .limit(limit)
    )).toQuery();

  return db.query(getInterestingExploitsQuery.text, getInterestingExploitsQuery.values)
    .nodeify(callback);
}

/**
 * Get the number of interesting exploits.
 * @param  {Function} [callback] optional err/result callback
 * @return {Promise}
 */
export function getInterestingExploitsCount(callback) {
  let getInterestingExploitsQuery = exploit.select(exploit.exploitId.count().as('count'))
    .where(exploit.exploitId.in(
      exploitPhishFrequency.subQuery().select(exploitPhishFrequency.exploitId)
      .order(exploitPhishFrequency.frequency.descending)
    )).toQuery();

  return db.queryOne(getInterestingExploitsQuery.text, [])
    .nodeify(callback);
}
